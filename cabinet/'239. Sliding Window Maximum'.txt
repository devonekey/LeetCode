import utils.*
import kotlin.math.*

/**
 * # 239. Sliding Window Maximum
 * ##### Topics: Array, Queue, Sliding Window, Heap (Priority Queue), Monotonic Queue
 * ##### Level: Hard
 * ##### Status: Time Limit Exceeded
 * ##### Language: Kotlin
 * ##### Explanation
 *
 * 수열(nums)과 크기를 나타내는 수(k)가 주어질 때, 특정 위치로부터 k 까지의 수 중에 최댓값을 찾아 배열에 넣고 반환하는 문제이다.
 */
class Solution {
    fun maxSlidingWindow(nums: IntArray, k: Int): IntArray {
        val answer = IntArray(nums.size - k + 1) { Int.MIN_VALUE }
        val window = mutableListOf<Int>()
        var maxNumIndex = 0

        nums.forEachIndexed { index, num ->
            val startIndex = max(index - k + 1, 0)

            window.add(index)

            if (window.size > k) {
                window.removeAt(0)
            }

            maxNumIndex = when {
                index >= k && maxNumIndex < startIndex ->
                    window.map { index -> index to nums[index] }
                        .maxWith(object : Comparator<Pair<Int, Int>> {
                            override fun compare(o1: Pair<Int, Int>, o2: Pair<Int, Int>): Int =
                                o1.second.compareTo(o2.second)
                        })
                        ?.first
                        ?: index
                nums[maxNumIndex] <= num -> index
                else -> maxNumIndex
            }

            if (window.size < k) {
                return@forEachIndexed
            }

            answer[startIndex] = nums[maxNumIndex]
        }

        return answer
    }
}

fun main() {
    Solution().maxSlidingWindow(nums = intArrayOf(1, 3, -1, -3, 5, 3, 6, 7), k = 3)
        .runTestcase(expected = intArrayOf(3, 3, 5, 5, 6, 7))
    Solution().maxSlidingWindow(nums = intArrayOf(1), k = 1)
        .runTestcase(expected = intArrayOf(1))
    Solution().maxSlidingWindow(nums = intArrayOf(1, -1), k = 1)
        .runTestcase(expected = intArrayOf(1, -1))
}
