import utils.*
import java.util.*

/**
 * # 1696. Jump Game VI
 * ##### Topics: Array, Dynamic Programming, Queue, Heap (Priority Queue), Monotonic Queue
 * ##### Level: Medium
 * ##### Status: Accepted
 * ##### Language: Kotlin
 * ##### Explanation
 *
 * 주어진 수열에서 k만큼 건너뛰기가 허용될 때, 수열 요소들 합의 최댓값을 구하는 문제다.
 *
 * 1. 주어진 수열(nums)을 순회한다.
 * 2. 우선 순위 큐(queue)를 순회하며 queue가 가리키는 위치와 현재 위치(index) 차가 k를 벗어나면 제거한다.
 * 3. queue가 가리키는 위치의 값을 더하여 nums에 기록한다.
 * 4. queue에 index를 추가한다.
 * 5. nums 마지막까지 순회하고 num의 마지막 수가 가리키는 값을 반환한다.
 *
 * 해당 풀이는 O(N Log K)의 성능으로, 최적의 성능은 아니다.
 */
class Solution {
    fun maxResult(nums: IntArray, k: Int): Int {
        val queue = PriorityQueue<Int>(compareByDescending<Int> { nums[it] })

        queue.add(0)
        (1..nums.lastIndex).forEach { index ->
            while (queue.isNotEmpty() && index - queue.peek() > k) {
                queue.poll()
            }

            nums[index] += nums[queue.peek()]

            queue.add(index)
        }

        return nums.last()
    }
}

fun main() {
    Solution().maxResult(nums = intArrayOf(1, -1, -2, 4, -7, 3), k = 2)
        .runTestcase(expected = 7)
    Solution().maxResult(nums = intArrayOf(10, -5, -2, 4, 0, 3), k = 3)
        .runTestcase(expected = 17)
    Solution().maxResult(nums = intArrayOf(1, -5, -20, 4, -1, 3, -6, -3), k = 2)
        .runTestcase(expected = 0)
    Solution().maxResult(nums = intArrayOf(100, -1, -100, -1, 100), k = 2)
        .runTestcase(expected = 198)
    Solution().maxResult(nums = intArrayOf(0, -1, -2, -3, 1), k = 2)
        .runTestcase(expected = -1)
}
